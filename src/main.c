// Adapted from gbdk hblank copy example by Rodrigo Rocha
#include <gbdk/platform.h>
#include <gb/hblankcpy.h>

#include <stdint.h>
#include <stdbool.h>

#include "blacktile.h"
// this file is generated by 'convert_png.py':
#include "data.h"

// X and Y posisions are centered
#define POSITION_X ((DEVICE_SCREEN_WIDTH - MAP_WIDTH) >> 1)
#define POSITION_Y ((DEVICE_SCREEN_HEIGHT - MAP_HEIGHT) >> 1)

// #define BUFFER_DOUBLE // uncomment for double buffering
#define HBLANK_DESTINATION  0 // 0 = 8000; 1 = 9000
#define TILE_OFFSET         1 // dont touch the first tile! remove to start at zero
#define TILE_OFFSET_SIZE    16 // tile bytes

uint8_t joy = 0, old_joy;
inline void PROCESS_INPUT(void) {
    old_joy = joy, joy = joypad();
}
inline uint8_t KEY_PRESSED(uint8_t key) {
    return ((joy & ~old_joy) & key);
}

bool animation = true;                              // animation enabled
bool step_animation = false;
bool animation_direction = true;                    // animate forward or back
uint8_t animation_speed = 4, animation_counter = 0; // animation speed and counter

const frame_desc_t * current_frame = frames;        // pointer to the current animation frame

#ifdef BUFFER_DOUBLE
void LCD_ISR(void) {
    static bool odd_even_frame = false;
    uint8_t _save = CURRENT_BANK;
    SWITCH_ROM(current_frame->bank);

    if (odd_even_frame = !odd_even_frame) {
        LCDC_REG &= ~LCDCF_BG8000;
        hblank_copy_destination = _VRAM8000+(TILE_OFFSET*TILE_OFFSET_SIZE);
        hblank_copy_vram(current_frame->tiles, MAP_WIDTH * MAP_HEIGHT);
    } else {
        LCDC_REG |= LCDCF_BG8000;
        hblank_copy_destination = _VRAM9000+(TILE_OFFSET*TILE_OFFSET_SIZE);
        hblank_copy_vram(current_frame->tiles, MAP_WIDTH * MAP_HEIGHT);
    }
    SWITCH_ROM(_save);
}
#else // single buffer
void LCD_ISR(void) {
    // static bool odd_even_frame = false;
    uint8_t _save = CURRENT_BANK;
    SWITCH_ROM(current_frame->bank);
    hblank_copy_vram(current_frame->tiles, MAP_WIDTH * MAP_HEIGHT);
    SWITCH_ROM(_save);
}
#endif

void main(void) {
    DISPLAY_OFF;

    CRITICAL {
        LYC_REG = 0, STAT_REG |= STATF_LYC;
        #if HBLANK_DESTINATION == 0
            LCDC_REG |= LCDCF_BG8000;
            hblank_copy_destination = _VRAM8000+(TILE_OFFSET*TILE_OFFSET_SIZE);
        #else
            LCDC_REG &= ~LCDCF_BG8000;
            hblank_copy_destination = _VRAM9000+(TILE_OFFSET*TILE_OFFSET_SIZE);
        #endif
        add_LCD(LCD_ISR);
    }
    set_interrupts(IE_REG | LCD_IFLAG);

    // set up palettes
    BGP_REG = DMG_PALETTE(DMG_DARK_GRAY, DMG_WHITE, DMG_LITE_GRAY, DMG_BLACK);
    cpu_fast();
    const palette_color_t bg_palette[4] = { RGBHTML(0x00303b), RGBHTML(0xa40000), RGBHTML(0xff8b40), RGBHTML(0xf1f2da) };
    set_bkg_palette(0, 1, bg_palette);
 
    set_bkg_data(0, 1u, blacktile_tiles); // The first 0x80u here is the tile ID
    // fill_bkg_rect(0u, 0u, DEVICE_SCREEN_WIDTH, DEVICE_SCREEN_HEIGHT, 0x80u);   // The last 0x80u here is the tile ID 

    // clear screen and set tile map
    fill_bkg_rect(0, 0, 32, 32, 0);
    uint8_t v = TILE_OFFSET;
    for (uint8_t y = POSITION_Y; y != POSITION_Y + MAP_HEIGHT; y++) {
        uint8_t * addr = set_bkg_tile_xy(POSITION_X, y, v++);
        for (uint8_t x = 0; x != MAP_WIDTH - 1; x++) set_vram_byte(++addr, v++);
    }

    SHOW_BKG;
    DISPLAY_ON;    

    while (true) {
        vsync();
        PROCESS_INPUT();
        // stepping through animation frames with LEFT/RIGHT
        if (joy & J_LEFT) {
            animation = false;
            animation_direction = false;
            step_animation = true;
        } else if (joy & J_RIGHT) {
            animation = false;
            animation_direction = true;
            step_animation = true;
        }
        // change the animation speed with UP/DOWN
        if (KEY_PRESSED(J_UP)) {
            if (animation_speed) animation_speed--;
        } else if (KEY_PRESSED(J_DOWN)) {
            if (++animation_speed > 10) animation_speed = 10;
        }
        // start/stop animation with START
        if (KEY_PRESSED(J_START)) animation  = !animation;

        // process animation
        if ((step_animation) || ((animation) && (++animation_counter > animation_speed))) {
            animation_counter = 0;
            if (animation_direction) CRITICAL {
                if (++current_frame == (frames + ANIMATION_FRAME_COUNT)) current_frame = frames;
            } else CRITICAL {
                if (--current_frame < frames) current_frame = frames + (ANIMATION_FRAME_COUNT - 1);
            }
            step_animation = false;
        }
    }
}